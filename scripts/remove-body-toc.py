#!/usr/bin/env python3
"""
Remove the Table of Contents from the HTML body.

The TOC is generated by Typst's #outline() function, but we don't need it in HTML
since we have a sidebar TOC. This script removes the TOC section from the body.

Usage: python3 remove-body-toc.py input.html [output.html]
"""

import re
import sys
from pathlib import Path


def remove_body_toc(html_content: str) -> tuple[str, bool]:
    """
    Remove the Table of Contents section from HTML body.

    Returns:
        tuple: (modified_html, was_removed)
    """
    # Pattern to match the TOC section wrapped in <nav role="doc-toc">
    # Look for:
    # - <nav role="doc-toc">
    # - Contains <h2>Table of Contents</h2>
    # - Contains nested <ol> lists
    # - Closes with </nav>

    # Try to find the nav wrapper first
    nav_pattern = r'<nav\s+role="doc-toc"[^>]*>.*?</nav>'
    nav_match = re.search(nav_pattern, html_content, re.DOTALL | re.IGNORECASE)

    if nav_match:
        # Found the nav wrapper - remove the entire <nav> section
        # But verify it contains "Table of Contents"
        nav_content = nav_match.group(0)
        if (
            "Table of Contents" in nav_content
            or "table of contents" in nav_content.lower()
        ):
            html_content = (
                html_content[: nav_match.start()] + html_content[nav_match.end() :]
            )
            return html_content, True

    # Fallback: try to find and remove the TOC heading and its following outline list
    # without nav wrapper
    pattern = r"<h2[^>]*>Table of Contents</h2>\s*</div>\s*<ol[^>]*>.*?</ol>"

    # Use DOTALL flag to match across newlines
    match = re.search(pattern, html_content, re.DOTALL | re.IGNORECASE)

    if match:
        # Found the TOC - now we need to be careful to remove the entire nested structure
        # Since the outline can have nested <ol> tags, we need a more sophisticated approach

        start_pos = match.start()

        # Find the h2 tag
        h2_match = re.search(
            r"<h2[^>]*>Table of Contents</h2>", html_content[start_pos:], re.IGNORECASE
        )
        if not h2_match:
            return html_content, False

        toc_start = start_pos + h2_match.start()

        # Find the start of the outline list after the h2
        after_h2 = start_pos + h2_match.end()
        ol_match = re.search(r"<ol[^>]*>", html_content[after_h2:])

        if not ol_match:
            return html_content, False

        ol_start = after_h2 + ol_match.start()

        # Now find the matching closing </ol> by counting nested ol tags
        ol_count = 0
        pos = ol_start
        ol_end = None

        while pos < len(html_content):
            # Look for next <ol> or </ol>
            next_open = html_content.find("<ol", pos)
            next_close = html_content.find("</ol>", pos)

            if next_close == -1:
                break

            if next_open != -1 and next_open < next_close:
                ol_count += 1
                pos = next_open + 3
            else:
                if ol_count == 0:
                    # Found the matching closing tag
                    ol_end = next_close + 5  # Include </ol>
                    break
                else:
                    ol_count -= 1
                    pos = next_close + 5

        if ol_end is None:
            return html_content, False

        # Also remove any wrapper divs around the TOC
        # Look backwards for a div opening before the h2
        look_back = 200
        search_start = max(0, toc_start - look_back)
        pre_toc = html_content[search_start:toc_start]

        # Find the last <div> before the TOC
        div_matches = list(re.finditer(r"<div[^>]*>", pre_toc))
        if div_matches:
            last_div = div_matches[-1]
            actual_start = search_start + last_div.start()

            # Check if there's a corresponding </div> after the ol_end
            post_ol = html_content[ol_end : ol_end + 50]
            if post_ol.strip().startswith("</div>"):
                close_div_end = ol_end + post_ol.find("</div>") + 6
                # Remove from div start to div end
                html_content = (
                    html_content[:actual_start] + html_content[close_div_end:]
                )
                return html_content, True

        # If no div wrapper found, just remove from h2 to ol_end
        # Also check for a closing </div> right after
        check_after = html_content[ol_end : ol_end + 50]
        if check_after.strip().startswith("</div>"):
            ol_end = ol_end + check_after.find("</div>") + 6

        html_content = html_content[:toc_start] + html_content[ol_end:]
        return html_content, True

    return html_content, False


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: python3 remove-body-toc.py input.html [output.html]")
        print("\nRemoves the Table of Contents section from HTML body")
        print("(keeps the sidebar TOC)")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    output_file = Path(sys.argv[2]) if len(sys.argv) > 2 else input_file

    if not input_file.exists():
        print(f"Error: Input file not found: {input_file}")
        sys.exit(1)

    # Read HTML
    html_content = input_file.read_text(encoding="utf-8")

    # Remove TOC
    html_content, was_removed = remove_body_toc(html_content)

    if was_removed:
        print("✓ Removed Table of Contents from HTML body")
    else:
        print("ℹ No Table of Contents found in HTML body")

    # Write output
    output_file.write_text(html_content, encoding="utf-8")
    print(f"✓ Output written to: {output_file}")


if __name__ == "__main__":
    main()
