#!/usr/bin/env python3
"""
Post-processor to add Bootstrap classes to HTML elements generated by Typst.

This script:
1. Adds Bootstrap table classes to tables
2. Adds Bootstrap typography classes
3. Adds responsive utility classes
4. Preserves existing structure and content

Usage:
    python3 add-bootstrap-classes.py input.html output.html
"""

import re
import sys
from pathlib import Path
from html.parser import HTMLParser


class BootstrapClassAdder(HTMLParser):
    """HTML parser that adds Bootstrap classes to elements."""

    def __init__(self):
        super().__init__()
        self.output = []
        self.in_table = False
        self.in_thead = False
        self.in_tbody = False
        self.table_row_count = 0
        self.in_table_first_row = False

    def handle_starttag(self, tag, attrs):
        """Process opening tags and add Bootstrap classes."""
        attrs_dict = dict(attrs)
        new_classes = []

        # Add existing classes
        if "class" in attrs_dict:
            new_classes.append(attrs_dict["class"])

        # Table elements
        if tag == "table":
            self.in_table = True
            self.table_row_count = 0
            new_classes.append("table table-hover table-bordered")
            attrs_dict["class"] = " ".join(new_classes)

        elif tag == "thead":
            self.in_thead = True
            new_classes.append("table-primary")
            attrs_dict["class"] = " ".join(new_classes)

        elif tag == "tbody":
            self.in_tbody = True

        elif tag == "tr" and self.in_table:
            self.table_row_count += 1
            if self.table_row_count == 1 and not self.in_thead and not self.in_tbody:
                # First row is header if no thead
                self.in_table_first_row = True

        elif tag == "th":
            new_classes.append("fw-bold text-uppercase")
            attrs_dict["class"] = " ".join(new_classes)

        elif tag == "td":
            # Add padding classes
            if "class" not in attrs_dict:
                new_classes.append("align-top")
                attrs_dict["class"] = " ".join(new_classes)

        # Headings
        elif tag in ["h1", "h2", "h3", "h4", "h5", "h6"]:
            new_classes.append("mt-4 mb-3")
            attrs_dict["class"] = " ".join(new_classes)

        # Lists
        elif tag == "ul":
            if not self.in_table:  # Don't add to lists in tables
                new_classes.append("list-unstyled")
                attrs_dict["class"] = " ".join(new_classes)

        # Links
        elif tag == "a":
            if "class" not in attrs_dict or "btn" not in attrs_dict.get("class", ""):
                new_classes.append("link-primary")
                attrs_dict["class"] = " ".join(new_classes)

        # Rebuild tag with new attributes
        attrs_str = " ".join(
            f'{k}="{v}"' if v is not None else k for k, v in attrs_dict.items()
        )
        self.output.append(f"<{tag} {attrs_str}>" if attrs_str else f"<{tag}>")

    def handle_endtag(self, tag):
        """Process closing tags."""
        if tag == "table":
            self.in_table = False
            self.table_row_count = 0
        elif tag == "thead":
            self.in_thead = False
        elif tag == "tbody":
            self.in_tbody = False
        elif tag == "tr" and self.in_table_first_row:
            self.in_table_first_row = False

        self.output.append(f"</{tag}>")

    def handle_data(self, data):
        """Process text content."""
        self.output.append(data)

    def handle_startendtag(self, tag, attrs):
        """Process self-closing tags."""
        attrs_dict = dict(attrs)
        attrs_str = " ".join(
            f'{k}="{v}"' if v is not None else k for k, v in attrs_dict.items()
        )
        self.output.append(f"<{tag} {attrs_str} />" if attrs_str else f"<{tag} />")

    def handle_comment(self, data):
        """Preserve comments."""
        self.output.append(f"<!--{data}-->")

    def handle_decl(self, decl):
        """Preserve declarations."""
        self.output.append(f"<!{decl}>")

    def get_output(self):
        """Get the processed HTML."""
        return "".join(self.output)


def add_bootstrap_classes(html_content: str) -> str:
    """
    Add Bootstrap classes to HTML elements using regex replacements.
    This is a simpler approach than full HTML parsing.
    """

    # Add Bootstrap table classes
    html_content = re.sub(
        r"<table(?![^>]*class=['\"])",
        '<table class="table table-hover table-bordered"',
        html_content,
    )

    # If table already has class, append Bootstrap classes
    html_content = re.sub(
        r'<table class="([^"]*)"',
        lambda m: f'<table class="{m.group(1)} table table-hover table-bordered"'
        if "table" not in m.group(1)
        else m.group(0),
        html_content,
    )

    # Add header classes to first table row (if it's not in a thead)
    # This is a heuristic - assumes first tr after <table> is header
    def add_header_class(match):
        """Add table-primary class to header rows."""
        table_tag = match.group(1)
        first_tr = match.group(2)

        # Check if there's a thead
        if "<thead>" not in table_tag:
            # Add class to first tr
            if 'class="' in first_tr:
                first_tr = first_tr.replace(
                    'class="', 'class="table-primary ', 1
                )
            else:
                first_tr = first_tr.replace("<tr", '<tr class="table-primary"', 1)

        return table_tag + first_tr

    # Match table followed by first tr
    html_content = re.sub(
        r"(<table[^>]*>[\s\S]*?)(<tr[^>]*>)",
        add_header_class,
        html_content,
        count=0,  # Apply to all tables
    )

    # Add Bootstrap classes to headings
    for level in range(1, 7):
        html_content = re.sub(
            f"<h{level}(?![^>]*class=['\"])",
            f'<h{level} class="mt-4 mb-3"',
            html_content,
        )

    # Add link classes
    html_content = re.sub(
        r'<a(?![^>]*class=[\'"])([^>]*)>',
        r'<a class="link-primary"\1>',
        html_content,
    )

    # Add responsive image classes to diagrams
    html_content = re.sub(
        r'<svg(?![^>]*class=[\'"])',
        '<svg class="img-fluid"',
        html_content,
    )

    return html_content


def main():
    """Main entry point."""
    if len(sys.argv) < 3:
        print("Usage: python3 add-bootstrap-classes.py input.html output.html")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    output_file = Path(sys.argv[2])

    if not input_file.exists():
        print(f"Error: Input file not found: {input_file}")
        sys.exit(1)

    print(f"Adding Bootstrap classes to {input_file}...")

    # Read HTML content
    html_content = input_file.read_text(encoding="utf-8")

    # Add Bootstrap classes
    html_content = add_bootstrap_classes(html_content)

    # Write output
    output_file.write_text(html_content, encoding="utf-8")

    print(f"✓ Successfully added Bootstrap classes → {output_file}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
