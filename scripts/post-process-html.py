#!/usr/bin/env python3
"""
HTML post-processor for embedding SVG diagrams.

DEPRECATED: This script is being phased out in favor of html.frame approach.
The new approach generates inline SVGs directly via Typst's html.frame feature,
which are then recolored dynamically via JavaScript (diagram-theme-switcher.js).

Legacy functionality (for backward compatibility):
1. Reads the HTML file generated by Typst
2. Finds image placeholders (or empty divs where diagrams should be)
3. Injects both light and dark theme SVG versions inline
4. Adds CSS for theme switching
5. Adds JavaScript for automatic theme detection

Usage:
    python3 post-process-html.py input.html output.html
"""

import re
import sys
from pathlib import Path


def load_svg_content(svg_file: Path) -> str:
    """Load and clean SVG content."""
    try:
        svg_content = svg_file.read_text()
        # Extract just the SVG element (remove XML declaration if present)
        svg_start = svg_content.find("<svg")
        if svg_start != -1:
            svg_content = svg_content[svg_start:]
        return svg_content
    except Exception as e:
        print(f"  ‚úó Error reading {svg_file.name}: {e}")
        return ""


def inject_dual_theme_svg(diagrams_dir: Path, base_name: str) -> str:
    """Load both light and dark theme SVGs and wrap them with theme classes."""
    light_svg_file = diagrams_dir / f"{base_name}-light.svg"
    dark_svg_file = diagrams_dir / f"{base_name}-dark.svg"

    light_svg = load_svg_content(light_svg_file) if light_svg_file.exists() else ""
    dark_svg = load_svg_content(dark_svg_file) if dark_svg_file.exists() else ""

    if not light_svg and not dark_svg:
        print(
            f"  ‚ö† Warning: Neither {base_name}-light.svg nor {base_name}-dark.svg found"
        )
        return ""

    # If only one exists, use it for both themes
    if not light_svg:
        light_svg = dark_svg
    if not dark_svg:
        dark_svg = light_svg

    print(f"  ‚úì Injected {base_name}-light.svg and {base_name}-dark.svg")

    return f"""<div class="diagram-container">
      <div class="diagram-light" data-theme="light">
{light_svg}
      </div>
      <div class="diagram-dark" data-theme="dark">
{dark_svg}
      </div>
    </div>"""


def inject_svgs_into_html(html_content: str, diagrams_dir: Path) -> str:
    """Inject dual-theme SVG content into HTML where diagrams should appear."""

    # Find all img tags with diagram SVG sources (file paths)
    img_pattern = r'<img[^>]*src="([^"]*diagrams/([^/"]+)\.svg)"[^>]*>'

    def replace_img_with_dual_svg(match):
        base_name = match.group(2)
        return inject_dual_theme_svg(diagrams_dir, base_name)

    html_content = re.sub(img_pattern, replace_img_with_dual_svg, html_content)

    # Also handle data URI images (base64 encoded SVGs from Typst HTML export)
    # Pattern matches figure elements with captions containing known diagram names
    diagram_mappings = {
        "V-Model Software Development Lifecycle": "v-model",
        "System Architecture": "architecture",
        "Data Flow Through System": "data-flow",
        "Workflow State Machine": "state-machine",
        "Documentation Build Pipeline": "build-pipeline",
    }

    # Replace figure elements that contain data URI SVG images
    for caption_text, base_name in diagram_mappings.items():
        # Pattern: <figure>...<img src="data:image/svg+xml...>...<figcaption>Figure X: Caption</figcaption></figure>
        # We want to replace the img tag with dual-theme SVG while keeping the figure wrapper
        # The caption may include "Figure X: " prefix with regular or non-breaking space
        # Use [^<]* to match content without starting a new tag (prevents crossing element boundaries)
        # This ensures we only match within the intended figure element
        pattern = rf'(<figure[^>]*>\s*<img[^>]*src="data:image/svg\+xml;base64,[^"]*"[^>]*>\s*)(<figcaption[^>]*>Figure[\s\xa0]+\d+:[\s\xa0]+{re.escape(caption_text)}.*?</figcaption>\s*</figure>)'

        def replace_figure_img(match, base_name=base_name):
            svg_html = inject_dual_theme_svg(diagrams_dir, base_name)
            if svg_html:
                # Return figure opening tag + SVG + figcaption + figure closing tag
                return (
                    match.group(1)[: match.group(1).find("<img")]
                    + svg_html
                    + "\n    "
                    + match.group(2)
                )
            return match.group(0)  # Return original if SVG not found

        html_content = re.sub(
            pattern, replace_figure_img, html_content, flags=re.DOTALL
        )

    return html_content


def add_theme_switching_css(html_content: str) -> str:
    """Add CSS for theme-based diagram visibility (LEGACY - for backward compatibility)."""

    # Check if theme CSS is already embedded in a <style> tag
    if "/* Dual-theme diagram support */" in html_content:
        return html_content  # Already has theme CSS

    # Note: This CSS is for legacy dual-SVG approach only.
    # New html.frame approach doesn't need this CSS.
    theme_css = """    <style>
/* Dual-theme diagram support (LEGACY) */
.diagram-container {
  text-align: center;
  padding: 1em 0;
  margin: 1em 0;
}

/* Show/hide diagrams based on theme */
.diagram-light,
.diagram-dark {
  display: none;
}

/* Show light diagram in light mode */
[data-bs-theme="light"] .diagram-light,
[data-theme="light"] .diagram-light {
  display: block !important;
}

/* Show dark diagram in dark mode */
[data-bs-theme="dark"] .diagram-dark,
[data-theme="dark"] .diagram-dark {
  display: block !important;
}

/* Default: show light theme when no theme attribute is set */
:root:not([data-bs-theme]):not([data-theme]) .diagram-light {
  display: block;
}

/* System preference dark mode */
@media (prefers-color-scheme: dark) {
  :root:not([data-bs-theme]):not([data-theme]) .diagram-light {
    display: none;
  }

  :root:not([data-bs-theme]):not([data-theme]) .diagram-dark {
    display: block;
  }
}

.diagram-container svg {
  max-width: 100%;
  height: auto;
}
    </style>
"""

    # Find </head> tag and insert before it
    head_end = html_content.find("</head>")
    if head_end != -1:
        html_content = html_content[:head_end] + theme_css + html_content[head_end:]
        print("  ‚úì Added theme switching CSS (legacy)")

    return html_content


def add_theme_toggle_script(html_content: str) -> str:
    """Add JavaScript for theme toggle functionality (LEGACY - for backward compatibility)."""

    if "themeToggle" in html_content:
        return html_content  # Already has theme toggle script

    # Note: This JS is for legacy approach. New approach uses diagram-theme-switcher.js
    theme_script = """    <script>
// Theme toggle functionality
(function() {
  // Get current theme from localStorage or system preference
  function getPreferredTheme() {
    const storedTheme = localStorage.getItem('theme');
    if (storedTheme) {
      return storedTheme;
    }
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }

  // Set theme on document
  function setTheme(theme) {
    document.documentElement.setAttribute('data-bs-theme', theme);
    document.documentElement.setAttribute('data-theme', theme); // Backward compatibility
    localStorage.setItem('theme', theme);
  }

  // Toggle theme
  function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-bs-theme') || 'light';
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    setTheme(newTheme);
  }

  // Initialize theme on page load
  setTheme(getPreferredTheme());

  // Add theme toggle button if not exists
  window.addEventListener('DOMContentLoaded', function() {
    // Only add toggle if there isn't one already
    if (!document.getElementById('theme-toggle')) {
      const toggleBtn = document.createElement('button');
      toggleBtn.id = 'theme-toggle';
      toggleBtn.className = 'theme-toggle-btn';
      toggleBtn.innerHTML = 'üåì';
      toggleBtn.setAttribute('aria-label', 'Toggle dark mode');
      toggleBtn.addEventListener('click', toggleTheme);
      document.body.appendChild(toggleBtn);
    }
  });

  // Watch for system theme changes
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
    if (!localStorage.getItem('theme')) {
      setTheme(e.matches ? 'dark' : 'light');
    }
  });
})();
    </script>
    <style>
/* Theme toggle button styling */
.theme-toggle-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: 2px solid #ccc;
  background: var(--bs-body-bg, white);
  font-size: 24px;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  transition: all 0.3s ease;
  z-index: 1000;
}

.theme-toggle-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

[data-bs-theme="dark"] .theme-toggle-btn,
[data-theme="dark"] .theme-toggle-btn {
  background: #2d2d2d;
  border-color: #555;
}
    </style>
"""

    # Find </body> tag and insert before it
    body_end = html_content.find("</body>")
    if body_end != -1:
        html_content = html_content[:body_end] + theme_script + html_content[body_end:]
        print("  ‚úì Added theme toggle JavaScript (legacy)")

    return html_content


def main():
    """Main entry point."""
    print("=" * 60)
    print("‚ö†Ô∏è  DEPRECATION WARNING")
    print("=" * 60)
    print("This script is deprecated in favor of html.frame approach.")
    print("New workflow uses:")
    print("  - Typst html.frame for inline SVG generation")
    print("  - diagram-theme-switcher.js for dynamic recoloring")
    print("")
    print("This script is maintained for backward compatibility only.")
    print("=" * 60)
    print()

    if len(sys.argv) < 3:
        print("Usage: python3 post-process-html.py input.html output.html")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    output_file = Path(sys.argv[2])

    if not input_file.exists():
        print(f"Error: Input file not found: {input_file}")
        sys.exit(1)

    # Determine diagrams directory - check build/ first, then fall back to source
    # If HTML is in build/, diagrams should be in build/diagrams/
    # Otherwise, look in the project's diagrams/ directory
    if "build" in input_file.parts:
        # HTML is in build directory, use build/diagrams/
        diagrams_dir = input_file.parent / "diagrams"
        if not diagrams_dir.exists():
            # Fall back to source diagrams directory
            diagrams_dir = input_file.parent.parent / "diagrams"
    else:
        # HTML is in root, use project/diagrams/
        diagrams_dir = input_file.parent / "diagrams"

    print(f"Processing {input_file}...")
    print(f"Diagrams directory: {diagrams_dir}")
    print(f"Diagrams exist: {diagrams_dir.exists()}")
    print("=" * 60)

    # Read HTML content
    html_content = input_file.read_text()

    # Inject dual-theme SVGs
    print("\nInjecting dual-theme SVG diagrams...")
    html_content = inject_svgs_into_html(html_content, diagrams_dir)

    # Add theme switching CSS
    print("\nAdding theme switching CSS...")
    html_content = add_theme_switching_css(html_content)

    # Add theme toggle JavaScript
    print("\nAdding theme toggle JavaScript...")
    html_content = add_theme_toggle_script(html_content)

    # Write output
    output_file.write_text(html_content)

    print("\n" + "=" * 60)
    print(f"‚úì Successfully processed HTML ‚Üí {output_file}")
    print("\nFeatures added:")
    print("  ‚Ä¢ Dual-theme diagrams (light + dark)")
    print("  ‚Ä¢ Automatic theme detection (system preference)")
    print("  ‚Ä¢ Theme toggle button (top-right corner)")
    print("  ‚Ä¢ Theme persistence (localStorage)")
    print("\nNext steps:")
    print("  ‚Ä¢ Open the HTML in a browser to test theme switching")
    print("  ‚Ä¢ Click the üåì button to toggle between light/dark modes")

    return 0


if __name__ == "__main__":
    sys.exit(main())
